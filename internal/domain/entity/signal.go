package entity

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

// SignalType represents the type of trading signal
type SignalType string

const (
	SignalTypeLong  SignalType = "LONG"
	SignalTypeShort SignalType = "SHORT"
)

// SignalStatus represents the status of a signal
type SignalStatus string

const (
	SignalStatusPending     SignalStatus = "PENDING"
	SignalStatusConfirmed   SignalStatus = "CONFIRMED"
	SignalStatusInvalidated SignalStatus = "INVALIDATED"
	SignalStatusTracking    SignalStatus = "TRACKING"
	SignalStatusClosed      SignalStatus = "CLOSED"
)

// Signal represents a trading signal generated by a strategy
type Signal struct {
	ID       int64
	SignalID string // UUID
	Symbol   string

	// Signal details
	Type         SignalType
	StrategyName string

	// Market conditions at signal time
	GeneratedAt        time.Time
	PriceAtSignal      decimal.Decimal
	LongAccountRatio   decimal.Decimal
	ShortAccountRatio  decimal.Decimal
	LongPositionRatio  decimal.Decimal
	ShortPositionRatio decimal.Decimal
	LongTraderCount    int
	ShortTraderCount   int

	// Confirmation tracking
	ConfirmationStart time.Time
	ConfirmationEnd   time.Time
	IsConfirmed       bool
	ConfirmedAt       *time.Time

	// Signal status
	Status SignalStatus

	// Metadata
	Reason         string
	ConfigSnapshot map[string]interface{}

	CreatedAt time.Time
	UpdatedAt time.Time
}

// NewSignal creates a new signal
func NewSignal(symbol string, signalType SignalType, strategyName string, marketData *MarketData, confirmationHours int, reason string, config map[string]interface{}) *Signal {
	now := time.Now()
	confirmationEnd := now.Add(time.Duration(confirmationHours) * time.Hour)

	return &Signal{
		SignalID:           uuid.New().String(),
		Symbol:             symbol,
		Type:               signalType,
		StrategyName:       strategyName,
		GeneratedAt:        now,
		PriceAtSignal:      marketData.Price,
		LongAccountRatio:   marketData.LongAccountRatio,
		ShortAccountRatio:  marketData.ShortAccountRatio,
		LongPositionRatio:  marketData.LongPositionRatio,
		ShortPositionRatio: marketData.ShortPositionRatio,
		LongTraderCount:    marketData.LongTraderCount,
		ShortTraderCount:   marketData.ShortTraderCount,
		ConfirmationStart:  now,
		ConfirmationEnd:    confirmationEnd,
		IsConfirmed:        false,
		Status:             SignalStatusPending,
		Reason:             reason,
		ConfigSnapshot:     config,
		CreatedAt:          now,
		UpdatedAt:          now,
	}
}

// Validate validates the signal
func (s *Signal) Validate() error {
	if s.SignalID == "" {
		return fmt.Errorf("signal_id is required")
	}

	if s.Symbol == "" {
		return fmt.Errorf("symbol is required")
	}

	if s.Type != SignalTypeLong && s.Type != SignalTypeShort {
		return fmt.Errorf("invalid signal type: %s", s.Type)
	}

	if s.StrategyName == "" {
		return fmt.Errorf("strategy_name is required")
	}

	if s.PriceAtSignal.LessThanOrEqual(decimal.Zero) {
		return fmt.Errorf("price_at_signal must be positive")
	}

	return nil
}

// Confirm confirms the signal
func (s *Signal) Confirm() error {
	if s.Status != SignalStatusPending {
		return fmt.Errorf("cannot confirm signal with status: %s", s.Status)
	}

	now := time.Now()
	s.IsConfirmed = true
	s.ConfirmedAt = &now
	s.Status = SignalStatusConfirmed
	s.UpdatedAt = now

	return nil
}

// Invalidate invalidates the signal
func (s *Signal) Invalidate() error {
	if s.Status != SignalStatusPending && s.Status != SignalStatusConfirmed {
		return fmt.Errorf("cannot invalidate signal with status: %s", s.Status)
	}

	s.Status = SignalStatusInvalidated
	s.UpdatedAt = time.Now()

	return nil
}

// StartTracking starts tracking the signal
func (s *Signal) StartTracking() error {
	if s.Status != SignalStatusConfirmed {
		return fmt.Errorf("cannot start tracking signal with status: %s", s.Status)
	}

	s.Status = SignalStatusTracking
	s.UpdatedAt = time.Now()

	return nil
}

// Close closes the signal
func (s *Signal) Close() error {
	if s.Status != SignalStatusTracking {
		return fmt.Errorf("cannot close signal with status: %s", s.Status)
	}

	s.Status = SignalStatusClosed
	s.UpdatedAt = time.Now()

	return nil
}

// IsInConfirmationPeriod checks if the signal is still in confirmation period
func (s *Signal) IsInConfirmationPeriod() bool {
	return time.Now().Before(s.ConfirmationEnd)
}

// ConfirmationPeriodElapsed checks if the confirmation period has elapsed
func (s *Signal) ConfirmationPeriodElapsed() bool {
	return !s.IsInConfirmationPeriod()
}

// HoursElapsed returns the number of hours elapsed since signal generation
func (s *Signal) HoursElapsed() float64 {
	return time.Since(s.GeneratedAt).Hours()
}

// ShouldTrack determines if the signal should still be tracked
func (s *Signal) ShouldTrack(maxTrackingHours int) bool {
	if s.Status == SignalStatusClosed || s.Status == SignalStatusInvalidated {
		return false
	}

	return s.HoursElapsed() < float64(maxTrackingHours)
}

// CalculatePriceChange calculates the price change from signal price
func (s *Signal) CalculatePriceChange(currentPrice decimal.Decimal) decimal.Decimal {
	if s.PriceAtSignal.IsZero() {
		return decimal.Zero
	}

	change := currentPrice.Sub(s.PriceAtSignal).Div(s.PriceAtSignal).Mul(decimal.NewFromInt(100))

	// For SHORT signals, invert the change (negative becomes positive)
	if s.Type == SignalTypeShort {
		return change.Neg()
	}

	return change
}

// IsFavorable checks if the price movement is favorable for the signal
func (s *Signal) IsFavorable(currentPrice decimal.Decimal) bool {
	change := s.CalculatePriceChange(currentPrice)
	return change.GreaterThan(decimal.Zero)
}

// GetExpectedDirection returns the expected price direction for the signal
func (s *Signal) GetExpectedDirection() string {
	if s.Type == SignalTypeLong {
		return "UP"
	}
	return "DOWN"
}

// ConfigSnapshotJSON returns the config snapshot as JSON string
func (s *Signal) ConfigSnapshotJSON() (string, error) {
	if s.ConfigSnapshot == nil {
		return "{}", nil
	}

	data, err := json.Marshal(s.ConfigSnapshot)
	if err != nil {
		return "", fmt.Errorf("failed to marshal config snapshot: %w", err)
	}

	return string(data), nil
}

// SetConfigSnapshotFromJSON sets the config snapshot from JSON string
func (s *Signal) SetConfigSnapshotFromJSON(jsonStr string) error {
	var config map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &config); err != nil {
		return fmt.Errorf("failed to unmarshal config snapshot: %w", err)
	}

	s.ConfigSnapshot = config
	return nil
}

// String returns a string representation of the signal
func (s *Signal) String() string {
	return fmt.Sprintf("Signal{ID: %s, Symbol: %s, Type: %s, Strategy: %s, Status: %s, Price: %s, Generated: %s}",
		s.SignalID,
		s.Symbol,
		s.Type,
		s.StrategyName,
		s.Status,
		s.PriceAtSignal.String(),
		s.GeneratedAt.Format(time.RFC3339),
	)
}
